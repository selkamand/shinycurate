% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_helpers.R
\name{write_to_database}
\alias{write_to_database}
\title{Write a row to SQLite using a template (typed, safe, upsert)}
\usage{
write_to_database(conn, id, values, template, table = "table1")
}
\arguments{
\item{conn}{A `DBIConnection`.}

\item{id}{Row identifier (character scalar). If `values[["id"]]`
is present, it is ignored in favor of this argument.}

\item{values}{Named list of scalars for columns in the template (excluding `id`).
Extra names are ignored; missing names become NULL.}

\item{template}{Named character vector of SQLite types ("TEXT", "REAL",
"INTEGER", "BOOLEAN"). Names are column names.}

\item{table}{Table name. Default "table1".}
}
\value{
Invisibly, a list with elements:
        `action` = "update" or "insert", and `rows` = rows affected (integer).
}
\description{
Given a DBI connection, an `id`, a named list of values, and a template
(named character vector of SQLite types), write the row into `table`.
Values are coerced to the appropriate SQLite-compatible representations:
  - "BOOLEAN" -> 0/1 (logical)
  - "REAL"/numeric types -> numeric
  - "INTEGER" -> integer
  - "TEXT" -> character
Missing entries in `values` become `NULL` (SQLite) for that column.

Uses an "upsert" implemented as UPDATE-then-INSERT inside a transaction,
so it does **not** require a UNIQUE constraint on `id`.
}
